---
layout: entry
title: 대칭형/비대칭형 암호 알고리즘
author: 김성중
author-email: ajax0615@gmail.com
description: 객체 지향 설계를 기반으로, 서버를 뒷받침할 다양한 컴포넌트, 클래스, 메서드를 고려하여 채팅 서버를 구현하는 인터뷰입니다.
publish: true
---

예전 방식의 암호화는 평문을 암호 알고리즘에 입력하여 암호화된 문장을 얻어내는 방식이었습니다. 하지만 이러한 방식은 암호 알고리즘이 노출될 경우 암호화된 문장을 누구나 해독할 수 있습니다. 그래서 현대의 암호화 알고리즘은 '평문 + KEY'를 입력 값으로 하여 암호화된 문장을 얻어냅니다. 마찬가지로 '암호문 + Key'를 입력값으로 복호화합니다. 이러한 방식은 암호화 알고리즘이 노출되더라도 Key값을 알지 못하면 복호화 할 수 없기 때문에 훨씬 안전하다는 장점이 있습니다.

현대 암호 알고리즘들은 크게 대칭형(Symmetric) 암호 알고리즘과 비 대칭형(Asymmetric) 암호 알고리즘으로 구분됩니다. **대칭형 암호 알고리즘** 은 암호화할 때 사용되는 Key값과 복호화 할 때 사용되는 Key값이 동일한 알고리즘이고, **비대칭형 암호 알고리즘** 은 암호화할 때 사용되는 Key값과 복호화 할 때 사용되는 Key값이 서로 다른 알고리즘입니다.

## 대칭형 암호 알고리즘
대칭형 암호 알고리즘은 다음과 같은 장점 때문에 주로 데이터 통신의 암호화에 사용됩니다.

![symmetric](/images/2016/09/30/symmetric.png "symmetric"){: .center-image }

* 암호화/복호화 속도가 비대칭형 암호 알고리즘보다 빠르다(최소10~최대1000배).

> 암호화/복호화 속도는 통신 속도에 많은 영향을 끼치므로 당연히 속도가 빠른 것이 통신에 유리하다.

* 암호문의 크기가 평문보다 크지 않다(암호화 시 데이터 증가가 없다).

> 크기가 증가하지 않는다는 것은 암호화된 데이터의 크기가 평문과 같다는 것이고, 네트워크 대역폭을 추가적으로 필요로 하지 않는다는 것이므로 통신에 적합하다.

하지만 대칭형 암호 알고리즘은 그 원리상 데이터를 송신하는 A와 데이터를 수신하는 B가 동일한 Key를 가져야 하는데, A와 B가 어떻게 같은 Key를 가질 수 있도록 해야 하는가? 라는 문제가 있습니다. 이를 Key bootstrapping 또는 Key agreement problem 이라고 합니다. A가 Key를 만들고 이 Key를 네트워크를 통해 B에게 전달하는 식의 방법은 공격자가 중간에서 Key를 가로챌 수 있기 때문에 사용할 수 없습니다.

이 문제를 해결하는 일반적인 방법은 두 가지가 있습니다. 첫번째는 Key를 뒤에서 설명할 비대칭형 암호 알고리즘을 이용하여 암호화 시킨 후 전송하는 방법입니다. 두번째는 실제 Key를 전송하지 않고도 A와 B가 동일한 Key를 생성할 수 있도록 하는 알고리즘을 사용하는 것인데 대표적으로 Diffie-Hellman 알고리즘이 있습니다. 그리고 대칭형 알고리즘의 예로는 SEED, DES, DES3, AES 등이 있습니다.

## 비대칭형 암호 알고리즘
비대칭형 암호 알고리즘은 흔히 **공개키 알고리즘** 이라고 불립니다. 비대칭형 알고리즘을 이용하여 데이터를 전송하는 방식은 다음과 같습니다.

A는 **공개키(public key)와 개인키(private key)** 를 생성한다. 생성된 공개키와 개인키는 수학적으로 다음과 같은 특성을 가진다.

> A의 공개키를 이용하여 암호화된 데이터는 A의 개인키로만 복호화가 가능하다.<br>
  A의 개인키를 이용하여 암호화된 데이터는 A의 공개키로만 복호화가 가능하다.

B 역시 A와 마찬가지로 공개키와 개인키를 생성합니다.

이제 A와 B가 통신하는 방법을 살펴봅시다. A와 B는 각자의 공개키를 서로에게 알려줍니다. 각자의 공개키를 나눠 갖게 되면 A는 공개A키, 개인A키, 공개B키를 가지고 있고, B는 공개B키, 개인B키, 공개A키를 가지고 있습니다. 공격자 물론 공개A키와 공개B키를 가지고 있겠죠. A는 B에게 데이터를 전송하기 위해 B의 공개B키를 이용하여 데이터를 암호화한 후 전송합니다. 암호화된 데이터는 개인B키를 가지고 있는 B만 해독할 수 있습니다. 이렇듯 공개키는 공개되더라도 안전하게 통신을 할 수 있습니다.

![asymmetric](/images/2016/09/30/asymmetric.png "asymmetric"){: .center-image }

대표적인 비대칭형 암호 알고리즘에는 RSA가 있고, 비대칭형 암호 알고리즘은 위에서 언급했던 것처럼 **대칭형 암호 알고리즘의 Key를 암호화** 하는데 사용하거나, 주로 **인증** 에 많이 사용됩니다. 예를 들어, C라는 고객이 Bank은행에서 인터넷 뱅킹을 한다고 가정해보자.

1. C는 Bank에 자신의 공개키를 보낸다.

2. Bank는 대칭형 암호 알고리즘에서 사용할 비밀키를 C의 공개키를 이용하여 암호화한 다음 전송한다.

3. C는 자신의 개인키로 복호화하여 Bank의 비밀키를 얻어낸다.

4. C와 Bank간의 통신은 전송받은 비밀키를 통해 암호화된다.

5. 공격자가 중간에서 암호화된 비밀키를 획득하더라도 C의 개인키를 알지 못하면 복호화 할 수 없기 때문에 비밀키로 암호화된 내용을 볼 수 없다.

그런데 여기에는 한 가지 문제점이 있습니다. 만약 공격자 A가 Bank에 접속해서 마치 자신이 C인 것처럼 가장하고 자신의 공개키로 전송하면 어떻게 될까요? 만약 Bank가 속는다면 Bank는 A의 공개키를 이용하여 비밀키를 암호화한 후에 전송할 것이고 A는 자신의 개인키로 이를 해독한 후 비밀키를 획득할 수 있게 될 것이다. 이러한 공격을 막기 위해서는 **Bank가 C의 공개키를 인증할 수 있는 방법** 이 필요합니다. 그게 바로 **인증서** 입니다. 인증서에는 인증받는 자(보통 target이라함)의 정보와 인증받는 자의 공개키, 유효 기간 등, 인증 기관 정보 등이 기록되어 있습니다. 인증서는 타겟의 공개키와 인증서에 기록된 공개키가 맞다는 사실을 인증기관이 보장한다는 내용을 담고 있습니다.
