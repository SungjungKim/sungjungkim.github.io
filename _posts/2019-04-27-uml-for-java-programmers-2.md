---
layout: entry
post-category: java
title: JAVA 프로그래머를 위한 UML - 2
author: 김성중
author-email: ajax0615@gmail.com
description: 로버트 C. 마틴의 'UML for Java Programmers'를 읽고 정리한 글입니다.
keywords: Java, 자바, UML
publish: true
---

# 4. 시퀀스 다이어그램

### 객체, 생명선, 메시지 등
협력에 참여하는 객체와 클래스는 맨위에 그리고, 객체는 이름 아래 밑줄이 있기 때문에 클래스와 구별된다. 왼쪽의 허수아비(액터)는 익명의 객체다. 이 객체는 협력 과정에 들어오고 나가는 모든 메시지의 시작점이자 마지막점이다.

![sequential-diagram](/images/2019/04/27/sequential-diagram.png "sequential-diagram"){: .center-image }

객체와 액터 아래에 늘어뜨린 점선은 생명선(lifeline)이라고 부른다. 한 객체에서 다른 객체로 보내는 메시지는 두 생명선 사이의 화살표로 그린다. 메시지마다 이름이 붙어 있다. 인자는 이름 뒤 괄호 안에 적거나, 데이터 토큰(반대쪽 끝에 원이 그려진 작은 화살표) 아래에 적는다.

LoginServlet 객체의 생명선에 있는 얇은 사각형은 활성 상자(activation)라고 부른다. 이 상자는 어떤 함수가 실행되는 시간을 나타낸다. EmployeeDB가 객체가 아니라 클래스라는 것에도 주목하라. 클래스는 객체와 비슷하지만 이름에 밑줄이 없다. 그러므로 getEmployee는 정적 메서드일 수밖에 없다.

### 생성과 소멸
이름이 붙지 않은 메시지 화살표의 끝이 객체의 생명선이 아니라 생성될 객체를 가리킨다.

![creating-object](/images/2019/04/27/creating-object.png "creating-object"){: .center-image }

자바에서 객체는 명시적으로 소멸되지 않으며, 가비지 컬렉터가 우리 대신 객체를 소멸시킨다. 우리가 해제하려고 하는 객체의 생명선이 X자로 일찌감치 끊겨 있다. 이 X자를 가리키는 메시지 화살표는 객체를 해제해서 가비지 컬렉터에 넘기는 행동을 뜻한ㄷ.

![releasing-object](/images/2019/04/27/releasing-object.png "releasing-object"){: .center-image }

### 사례와 시나리오
첫째, 무엇보다 자신에게 시퀀스 다이어그램이 정말 필요한지 물어보아라. 코드만으로 어떤 시스템의 일부분을 설명하는 것이 개발자와 설계자의 목표여야 한다. 개발팀은 표현력이 강하고 가독성 좋은 코드를 작성하기 위해 노력해야 한다. 코드만으로 설명하기 쉬울수록 필요한 다이어그램의 수도 줄어들고, 전체 프로젝트도 나아질 것이다.

둘째, 시퀀스 다이어그램이 필요하다는 생각이 들면 그것을 여러 시나리오로 쪼갤 수 있는지 자신에게 물어보아라.

![simple-scenario](/images/2019/04/27/simple-scenario.png "simple-scenario"){: .center-image }

셋째, 여러분이 무엇을 그리려고 하는지 생각해 보아라. 시스템의 전체 흐름에 대한 고차원의 개괄인가? 대개 고차원 다이어그램이 저차원 다이어그램보다 더 쓸모 있다. 고차원 다이어그램은 다이어그램을 읽는 사람이 마음속에서 시스템의 여러 요소를 하나로 연결해 볼 수 있게 해준다.

![high-level-view](/images/2019/04/27/high-level-view.png "high-level-view"){: .center-image }

### 반복과 조건
별표(\*)로 반복임을 표시하고 대괄호(\[\])로 조건임을 표시 할 수 있다.

### 비동기 메시지
분산 시스템이나 멀티스레드 시스템에서는 메시지를 보내는 객체가 다른 스레드의 제어 흐름에서 실행될 수도 있다. 이런 메시지 \'비동기 메시지(asynchronous message)\'라고 부른다.

![asynchronous-message](/images/2019/04/27/asynchronous-message.png "asynchronous-message"){: .center-image }

### 다중 스레드
비동기 메시지를 쓴다는 말은 곧 제어 흐름에서 다중 스레드를 사용한다는 뜻이다. 메시지 이름 앞에 T1 같은 식별자를  쓰고 콜론(:)을 찍어 놓은 것을 볼 수 있다. 이 식별자는 메시지를 보내는 스레드의 이름이다. 이 다이어그램에서 AsynchronousLogger 객체는 T1 스레드가 생성하고 조작한다. Log 객체 안에서 돌아가는, 실제로 메시지 로그를 수행하는 스레드는 T2라고 이름 붙어 있다.

![multiple-thread](/images/2019/04/27/multiple-thread.png "multiple-thread"){: .center-image }

### 활동적인 객체
독립된 내부 스레드를 가진 객체를 표현하고 싶은 객체를 표현하고 싶은 경우도 있다. 이런 객체는 활동적인 객체(active object)로 알려져 있다. 자신만의 스레드를 만들고 제어하는 객체는 모두 활동적인 객체다. 그 객체의 메서드에 대해서는 특별한 제한이 없다. 활동적인 객체의 메서드는 그 객체의 스레드에서 돌아가도 되고, 그 메서드를 호출하는 스레드에서 돌아가도 된다.

![active-objects](/images/2019/04/27/active-objects.png "active-objects"){: .center-image }

---

# 5. 유스케이스
유스케이스를 \'단순하게 유지하는 것\'이 유스케이스를 사용하는 진짜 비결이다. 정해진 형식을 맞춰야 하나 걱정하지 말고 그냥 \'빈 종이\'에 쓰거나, 단순한 워드프로세서로 \'빈 페이지\'에 작성하거나, \'텅 빈 인덱스 카드\'에 적어라. 모든 세부사항을 채워야 하는지 걱정할 필요도 없다. 유스케이스를 \'그때그때 작성하는 요구사항\'이라고 생각하라.

### 유스케이스란 무엇인가
유스케이스는 시스템의 동작 하나를 기술한 것이다. 유스케이스는 방금 시스템에 특정한 일을 시킨 사용자의 관점에서 작성하며, 사용자가 보낸 자극 \'하나\'에 대한 반응으로 시스템이 진행하는 \'눈에 보이는\' 이벤트들의 흐름을 포착한다.

눈에 보이는 이벤트란, 사용자가 볼 수 있는 이벤트를 뜻한다. 유스케이스는 사용자의 눈에 보이지 않는 동작을 전혀 기술하지 않고 시스템 안에 숨겨진 메커니즘도 다루지 않는다. 오직 사용자가 직접 볼 수 있는 것을 적어 놓을 뿐이다.

### 기본 흐름
유스케이스를 구성하는 항목은 보통 두 개다. 첫째 항목은 기본 흐름(primary course)이다. 예로 판매시점관리(point of sale, POS) 시스템의 전형적인 유스케이스를 보자.

**상품 구입하기**<br/>
1. 점원은 상품을 스캐너 위로 통과시킨다. 스캐너가 UPC 코드를 읽는다.
2. 상품 가격과 설명이 지금까지 통과시킨 상품 가격의 합계와 함께 고객 쪽 화면에 표시된다. 가격과 설명은 점원의 화면에도 표시된다.
3. 가격과 설명이 영수증에 출력된다.
4. UPC 코드가 올바르게 읽혔는지 점원이 확인할 수 있도록 시스템이 잘 들리는 \'승인\' 소리를 낸다.

### 대체 흐름
유스케이스의 세부사항 가운데 일부는 일이 잘못되는 경우를 고려해야 한다. 이해관계자와 대화할 때 여러분은 실패 시나리오를 이야기해 봐야 한다. 그리고 그 유스케이스를 구현할 시간이 다가올수록 이런 대체 흐름을 더 깊게 생각해야 한다. 대체 흐름은 기본 흐름에 부록처럼 붙게 되며, 다음처럼 작성한다.

**<UPC 코드를 읽지 못할 경우>**<br/>
만약 스캐너가 UPC 코드를 읽는 데 실패하면 시스템은 점원이 다시 시도하도록 \'다시 통과시키시오.\' 소리를 낸다. 만약 세 번 시도했는데도 스캐너가 UPC 코드를 인식하지 못하면, 점원은 직접 코드를 입력해야 한다.

**<UPC 코드가 없을 경우>**<br/>
상품에 UPC 코드가 없다면, 점원은 가격을 직접 입력해야 한다.

### 시스템 경계 다이어그램(System Boundary Diagram)
사각형 안에 들어있는 것은 모두 개발 중인 시스템의 일부다. 사각형 바깥을 보면 시스템을 상대로 행동하는 액터를 볼 수 있다. 액터란, 시스템에 자극을 가하며 시스템 바깥에 있는 존재다. 액터는 사용자인데 대개 사람이다. 하지만 다른 시스템이나 심지어 실시간 클럭(realtime clock) 같은 장치가 액터가 될 수도 있다.

경계 사각형 안을 보면 유스케이스들이 들어 있는데, 유스케이스는 타원 안에 그 유스케이스의 이름을 써서 나타낸다. 액터와 그 액터가 자극하는 유스케이스는 선으로 잇는다. 화살표는 그리지 마라. 화살표 방향이 정말로 무엇을 의미하는지 제대로 아는 사람은 아무도 없다.

![system-boundary-diagram](/images/2019/04/27/system-boundary-diagram.png "system-boundary-diagram"){: .center-image }

---

6. 객체지향 개발의 원칙




















---

# References
- [UML 실전에서는 이것만 쓴다: JAVA 프로그래머를 위한 UM](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788991268937)
- [UML_for_Java_Programmers](https://www.csd.uoc.gr/~hy252/references/UML_for_Java_Programmers-Book.pdf)
