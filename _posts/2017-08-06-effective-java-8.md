---
layout: entry
post-category: java
title: Effective Java(8)
author: 김성중
author-email: ajax0615@gmail.com
description: Effective Java의 9장(예외)을 정리한 글입니다.
publish: false
---

# 규칙 57. 예외는 예외적 상황에만 사용하라

```java
try {
  for (Mountain m : range)
    m.climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```

예외를 사용해 구현한 순환문은 코드의 원래 목적을 흐리고 성능을 떨어뜨릴 뿐 아니라, 올바른 동작을 보장할 수 없다는 문제도 갖고 있다. 관련 없는 버그 때문에 순환문이 조용히 종료되면 버그의 존재는 감춰지므로 디버깅이 어려워진다. 위 예제와 같은 순환문을 사용하게 되면 버그 때문에 예외가 생겼는지, 순환문이 끝나려고 예외가 발생했는지 분간할 수 없으므로 버그는 묻혀버리게 된다.

이 이야기가 주는 교훈은 간단하다. **이름이 말하듯이, 예외는 예외적인 상황에만 사용해야 한다. 평상시 제어 흐름(ordinary control flow)에 이용해서는 안 된다.**

이 원칙은 API 설계에도 적용된다. 잘 **설계된 API는 클라이언트에게 평상시 제어 흐름의 일부로 예외를 사용하도록 강요해서는 안 된다.** 특정한 예측 불가능 조건이 만족될 때만 호출할 수 있는 \"상태 종속적(state-dependent)\" 메서드를 가진 클래스에는 보통 해당 메서드를 호출해도 되는지를 알기 위한 \"상태 검사(state-testing)\" 메서드가 별도로 갖춰져 있다. 예를 들어, Iterator 인터페이스에는 상태 종속적 메서드 next가 있고, 상태 검사 메서드 hasNext가 있다. 그 덕에, 아래와 같은 표준적 for 숙어를 사용할 수 있다.

```
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
  Foo foo = i.next();
}
```

Iterator에 hasNext 메서드가 없었다면 클라이언트는 어쩔 수 없이 아래와 같은 코드를 만들어야 했을 것이다.

```java
// 물론 이렇게 하면 곤란
try {
  Iterator<Foo> i = collection.iterator();
  while (true) {
    Foo foo = i.next();
    ...
  }
} catch (NoSuchElementException e) {
}
```

상태 검사 메서드를 제공하기 싫다면, 부적절한 상태의 객체에 상태 종속적 메서드를 호출하면 null 같은 특이값(distinguished value)이 반환되도록 구현하는 방법도 있다. 그러나 이 기법은 Iterator에는 사용할 수 없는데, null은 next 메서드의 정상적 반환값 가운데 하나이기 때문이다.

---

# 규칙 58. 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
자바는 세 가지 종류의 \'throwable\'을 제공한다. *점검지정 예외*(checked exception), *실행시점 예외*(runtime exception), 그리고 *오류*(error)다.

점검지정 예외를 사용할 것인지 아니면 무점건 예외(unchecked exception)를 사용할 것인지에 대한 가장 기본적인 규칙은, **호출자(caller) 측에서 복구할 것으로 여겨지는 상황에 대해서는 점검지정 예외를 이용해야 한다**는 것이다. 점검지정 예외를 던지는 메서드를 호출한 클라이언트는 해당 예외를 catch 절 안에서 처리하든지, 아니면 계속 밖으로 던져지도록 놔두든지 해야 한다. 따라서 메서드에 선언된 점검지정 예외는 메서드를 호출하면 해당 예외와 관계된 상황이 발생할 수 있음을 API 사용자에게 알리는 구실을 한다.

API 사용자에게 점검지정 예외를 준다는 것은, 그 상태를 복구할 권한을 준다는 뜻이다. 사용자는 그 권한을 무시할 수 있다. catch로 에외를 받되(catch) 다른 처리를 하지 않아도 된다는 것이다. 하지만 일반적으로 그렇게 하면 곤란하다(규칙 65).

무점검(unchecked) \'throwable\'에는 실행시점 예외와 오류 두 가지가 있으며, 동작 방식은 같다. 둘 다 catch로 처리할 필요가 없으며, 일반적으로는 처리해서는 안 된다. 프로그램이 무점검 예외나 오류를 던진다는 것은 복구가 불가능한 상황에 직면했다는 뜻으로, 더 진행해 봐야 득보다 실이 더 크다는 뜻이다. 이런 throwable을 catch하지 않는 스레드는 적절한 오류 메시지를 내면서 중단(halt)된다.

**프로그래밍 오류를 표현할 때는 실행시점 예외를 사용하라.** 대부분의 실행시점 예외는 *선행조건 위반*(precondition violation)을 나타낸다. 클라이언트가 API 명세에 기술된 규약(contract)을 지키지 않았다는 뜻이다. 예를 들어, 배열 이용에 관한 규약에는 배열 첨자의 값이 0부터 배열 길이 -1 까지라고 되어 있다. 이 규약이 위반되면 ArrayIndexOutOfBoundsException이 발생한다.

Error는 JVM이 자원 부족(resource deficiency)이나 불변식 위반(invariant failure) 등, 더 이상 프로그램을 실행할 수 없는 상태에 도달했음을 알리기 위해 사용된다. 따라서 Error의 하위 클래스는 새로 만들지 말고, **사용자 정의 무점검 throwable은 RuntimeException의 하위 클래스로 만들어야 한다.**

### 요약
복구 가능한 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류를 나타내고 싶을 때는 실행시점 예외를 사용하라.

---

# 규칙 59. 불필요한 점검지정 예외 사용은 피하라
점검지정 예외는 예외적인 상황을 처리하도록 *강제*함으로써 안정성(reliability)를 높여준다. 하지만 남발하면 사용하기 불편한 API가 될 수 있다. 하나 이상의 점검지정 예외를 던지는 메서드를 호출할 때는 예외를 받아 처리하는 catch 블록을 하나 이상 만들든가, 아니면 예외를 다시 밖으로 던진다고 선언하고는 외부로 전파되도록 내버려둬야 한다.

메서드가 던지는 점검지정 예외가 *하나뿐*일 때 프로그래머가 느끼게 되는 부담은 큰 편이다. 예외가 여러 개라면, 하나의 try 블록에 달리는 catch 블록도 여러 개일 것이다. 반면 예외가 하나뿐이라면 catch 블록도 하나뿐일 것이다. 그 하나의 catch 블록 때문에 try 블록 안에서 메서드를 호출해야 하는 것이다. 이런 상황에 처하면 점검지정 예외를 없앨 방법이 없을지 고민해봐야 한다.

점검지정 예외를 무점검 예외로 바꾸는 한 가지 방법은, 예외를 던지는 메서드를 둘로 나눠서 첫 번째 메서드가 boolean 값을 반환하도록 만드는 것이다.

```java
// 예외를 점검하도록 지정된 메서드 호출
try {
  obj.action(args);
} catch (TheCheckedException e) {
  // 예외적 상황 처리
}
```

앞서 설명한 대로 메서드를 리팩터링하면 다음과 같다.

```java
// 상태 검사 메서드를 거쳐서 무점검 예외 메서드 호출
if (obj.actionPermitted(args)) {
  obj.action(args);
} else {
  // 예외적 상황 처리
}
```

action 호출이 항상 성공하리라고 확신하거나, 설사 실패해서 스레드가 죽어도 상관없다면 `obj.action(args)` 코드 한줄로 줄일 수 있다.

---

# 규칙 60. 표준 예외를 사용하라
자바 플랫폼 라이브러리에는 대부분의 API가 필요로 하는 기본적인 무점검 예외들이 갖추어져 있다. 이미 있는 예외들을 재사용하면 좋은 점이 많다. 배우기 쉽고 사용하기 편리한 API를 만들 수 있다. 그리고 그렇게 구현된 API는 가독성이 높다. 마지막으로, 예외 클래스 개수를 줄이면 프로그램의 메모리 요구량이 줄어들고, 클래스를 로딩하는 시간도 줄어든다.

가장 널리 재사용되는 예외는 IllegalArgumentException이다. 잘못된 값을 인자로 전달했을 때 발생하는 예외다. 예를 들어, 어떤 동작의 실행 횟수를 나타내는 인자에 음수가 전달되면 이 예외를 던져야 한다.

널리 쓰이는 또 다른 예외는 IllegalStateException이 있다. 현재 객체 상태로는 호출할 수 없는 메서드를 호출했을 때 발생하는 예외다. 예를 들어, 아직 적절히 초기화되지 않은 객체를 사용하려고 시도하면 이 예외가 발생할 것이다.

null 인자를 받으면 안되는 메서드에 null을 전달한 경우, IllegalArgumentException 대신 NullPointerException이 발생해야 한다. 이와 비슷하게, 어떤 순서열(sequence)의 첨자를 나타내는 인자에 참조 가능 범위를 벗어난 값이 전달되었을 때 IllegalArgumentException 대신 IndexOutOfBoundsException이 발생해야 한다.

ConcurrentModificationException은 하나의 스레드만 사용하도록 설계된 객체나, 외부적인 동기화 수단과 함께 이용되어야 하는 객체를 여러 스레드가 동시에 변경하려 하는 경우에 발생해야 하는 예외다.

UnsupportedOperationException은 어떤 객체가 호출된 메서드를 지원하지 않을 때 발생하는 예외다. 이 예외는 인터페이스에 정의된 선택적 메서드 가운데 하나 이상을 구현하지 않을 경우에 사용된다. 예를 들어, 객체를 추가하는 것만 가능한 리스트는 누군가 리스트에서 원소를 삭제하려고 하면 이 예외를 발생시킬 것이다.

---

# 규칙 61. 추상화 수준에 맞는 예외를 던져라
추상화 수준이 낮은 곳에서 발생한 예외를 그대로 밖으로 전달하면 관련성이 없는 예외가 발생하는 일이 생긴다. 그리고 추상화 수준이 높은 API가 구현 세부사항으로 오염되는 일까지 벌어진다.

이 문제를 피하려면 **상위 계층에서는 하위 계층에서 발생하는 예외를 반드시 받아서 상위 계층 추상화 수준에 맞는 예외로 바꿔서 던져야 한다.** 이를 *예외 변환*(exception translation)이라 부른다.

```java
// 예외 변환
try {
  // 낮은 수준의 추상화 계층 이용
  ...
} catch(LowerLevelException e) {
  throw new HigherLevelException(...);
}
```

*예외 연결*(exception chaining)은 예외 변환의 특별한 사례다. 하위 계층에서 발생한 예제 정보가 상위 계층 예외를 발생시킨 문제를 디버깅하는 데 유용할 때 사용한다. 하위 계층 예외(원인 cause)는 상위 계층 예외를 전달되는데, 상위 계층 예외에 있는 접근자 메서드(Throwable.getCause)를 호출하면 해당 정보를 꺼낼 수 있다.

```java
// 예외 연결
try {
  ... // 낮은 수준의 추상화 계층 이용
} catch (LowerLevelException cause) {
  throw new HigherLevelException(cause);
}
```

상위 계층 예외 HigherLevelException의 생성자는 문제의 \'원인\'을 *예외 연결을 지원하는*(chaining-aware) 상위 클래스 생성자에게 넘긴다. 해당 인자는 결국 Throwable의 예외 연결 지원 생성자에 전달된다. Throwable(Throwable)로 선언되어 있었을 것이다.

```java
// 예외 연결 지원 생성자를 갖춘 예외
class HigherLevelException extends Exception {
  HigherLevelException(Throwable cause) {
    super(cause);
  }
}
```

대부분의 표준 예외들은 예외 연결 지원 생성자를 구비하고 있다. 그런 생성자가 없는 예외에는 Throwable.initCause 메서드를 호출하면 하위 계층 예외를 연결할 수 있다. 예외 연결 기능을 사용하면 프로그램 안에서 예외의 원인에 접근할 수 있을 뿐 아니라(getCause를 이용해서), 최초에 발생한 예외의 스택 추적 정보(stack trace)를 상위 계층 예외에 통합할 수 있게 된다.

**아무 생각 없이 아래 계층에서 생긴 예외를 밖으로 전달하기만 하는 것보다야 예외 변환 기법이 낫지만, 남용하면 안 된다.** 가능하다면 제일 좋은 방법은 하위 계층에서 예외가 생기지 않도록 하는 것이다. 하위 계층 메서드가 예외 없이 수행될 수 있도록 하는 것이다.

하위 계층 메서드에서 예외가 발생하는 것을 막을 수 없다면, 좋은 방법으로는 하위 계층에서 생기는 문제를 상위 계층 메서드 호출자로부터 격리시키는 것이다. 하위 계층에서 발생하는 예외를 어떤 식으로든 처리해 버리는 것이다.

### 요약
하위 계층에서 발생하는 예외를 막거나 처리할 수 없다면, 상위 계층에 보여주면 곤란한 예외는 예외 변환을 통해 처리하라.

---

# 규칙 62. 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라


---

# 규칙 63. 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라


---

# 규칙 64. 실패 원자성 달성을 위해 노력하라


---

# 규칙 65. 예외를 무시하지 마라





















---

# Reference
- [Effective Java 2/E](http://www.insightbook.co.kr/%EB%8F%84%EC%84%9C-%EB%AA%A9%EB%A1%9D/programming-insight/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94effective-java-2e)
