---
layout: entry
post-category: refactoring
title: 리팩터링 2 - Refactoring 2
author: 김성중
author-email: ajax0615@gmail.com
description: 마틴 파울러의 리팩터링 2판(코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기)
keywords: 리팩터링, 리팩토링, refactoring
thumbnail-image: /images/profile/refactoring.png
publish: true
---

# 6. 기본적인 리팩터링
함수 구성과 이름 짓기는 가장 기본적인 저수준 리팩터링이다. 그런데 일단 함수를 만들고 나면 다시 고수준 모듈로 묶어야 한다.

### 6.1 함수 추출하기(Extract Function)
- 코드를 언제 독립된 함수로 묶어야 할지에 관한 의견은 수없이 많다. 길이를 기준으로 삼을 수 있다. 재사용성을 기준으로 할 수도 있다. \'목적과 구현을 분리\'하는 방식이 가장 합리적인 기준으로 보인다.
- 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는데 유리할 때가 많다. 성능 최적화에 대해서는 항상 일반적인 지침을 따르자.
- 이름이 떠오르지 않는다면 함수로 추출하면 안 된다는 신호다.
- 만약 변수가 초기화되는 지점과 실제로 사용되는 지점이 떨어져 있다면 문장 슬라이드하기를 활용하여 변수 조작을 모두 한곳에 처리하도록 모아두면 편하다.

### 6.2 함수 인라인하기(Inline Function)
- 때로는 함수 본문이 이름만큼 명확한 경우도 있다.
- 간접 호출을 너무 과하게 쓰는 코드도 흔한 인라인 대상이다.
- 실수하지 않으려면 한 번에 한 문장씩 옮기는 것이 좋다.
- 여기서 핵심은 항상 단계를 잘게 나눠서 처리하는 데 있다.

### 6.3 변수 추출하기(Extract Variable)
- 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다.
- 현재 함수 안에서만 의미가 있다면 변수로 추출하는 것이 좋다. 그러나 함수를 벗어난 넓은 문맥에서까지 의미가 된다면 그 넓은 범위에서 통용되는 이름을 생각해야 한다.
- 클래스 전체에 영향을 줄 때는 변수가 아닌 메서드로 추출하는 편이다.
- 객체는 특정 로직과 데이터를 외부와 공유하려 할 떄 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다.

### 6.4 변수 인라인하기(Inline Variable)
- 변수가 주변 코드를 리팩터링하는 데 방해가 되면 인라인하는 것이 좋다.

### 6.5 함수 선언 바꾸기(Change Function Declaration)
- 이름이 좋으면 함수의 구현 코드를 살펴볼 필요 없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있다.
- 먼저 변경 사항을 살펴보고 함수 선언과 호출문들을 단번에 고칠 수 있을지 가늠해본다.
- 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다.
- 이름 변경과 매개변수 추가를 모두 하고 싶다면 각각을 독립적으로 처리하자.
- 상속 구조 속에 있는 클래스의 메서드를 변경할 때는 다형 관계인 다른 클래스에도 변경이 반영되어야 한다.
- 원하는 형태의 메서드를 새로 만들어서 원래 함수를 호출하는 전달(forward) 메서드로 활용하는 것이다.
- 함수가 주(state) 식별 코드를 매개변수로 받도록 리팩터링할 것이다. 그러면 의존성이 제거되어 더 넓은 문맥에 활용할 수 있다.

### 6.6 변수 캡슐화하기(Encapsulate Variable)
- 함수는 데이터보다 다루기가 수월하다.
- 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다.
- 데이터의 유효범위가 넓을수록 캡슐화해야 한다. 레거시 코드를 다룰 때는 이런 변수를 참조하는 코드를 추가하거나 변경할 때마다 최대한 캡슐화한다. 그래야 자주 사용하는 데이터에 대한 결합도가 높아지는 일을 막을 수 있다.
- 불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다. 데이터가 변경될 일이 없어서 갱신 전 검증 같은 추가 로직이 자리할 공간을 마련할 필요가 없기 때문이다.
- 링크가 필요 없다면 데이터를 복제해 저장하여 나중에 원본이 변경돼서 발생하는 사고를 방지할 수 있다.

### 6.7 변수 이름 바꾸기(Rename Variable)
- 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경 써야 한다.

### 6.8 매개변수 객체 만들기(Introduce Parameter Object)
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다.
- 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기 때문에 일관성도 높여준다.

### 6.9 여러 함수를 클래스로 묶기(Combine Functions into Class)
- 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 또한 이런 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.
- 프로그램의 다른 부분에서 데이터를 갱신할 가능성이 꽤 있을 때는 클래스로 묶어두면 큰 도움이 된다.

### 6.10 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)
- 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.
- 변환 함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.
- 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다. 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 떄문이다.

### 6.11 단계 쪼개기(Split Phase)
- 코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다.
- 모듈이 잘 분리되어 있다면 다른 모듈의 상세 내용은 전혀 기억하지 못해도 원하는 대로 수정을 끝마칠 수도 있다.
- 각 단계는 자신만의 문제에 집중하기 때문에 나머지 관계에 대해서는 자세히 몰라도 이해할 수 있다.
- 다른 단계로 볼 수 있는 코드 영역들이 마침 서로 다른 데이터와 함수를 사용한다면 단계 쪼개기에 적합하다는 뜻이다.
- 핵심은 어디까지나 단계를 명확히 분리하는 데 있다.

---

# 7. 캡슐화
클래스는 본래 정보를 숨기는 용도로 설계되었다.

### 7.1 레코드 캡슐화하기(Encapsulate Record)
- 객체를 사용하면 어떻게 저장했는지를 숨긴 채 세 가지 값을 각각의 메서드로 제공할 수 있다. 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다.
- 캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한 곳에 모아두는 일이 중요하다. 데이터를 깊은 복사(deep copy)하여 반환하는 방법, 데이터 구조의 읽기전용 프락시를 반환하는 방법이 있다.
- 눈에 띄는 문제는 데이터 구조가 클수록 복제 비용이 커져서 성능이 느려질 수 있다는 것이다.
- 읽기전용 프락시를 제공하거나 복제본을 동결시켜서 데이터를 수정하려 할 때 에러를 던지도록 만들 수 있다.
- 레코드 캡슐화를 재귀적으로 하는 것으로, 할 일은 늘어나지만 가장 확실하게 제거할 수 있다.

### 7.2 컬렉션 캡슐화하기(Encapsulate Collection)
- 가변 데이터를 모두 캡슐화하는 편이다. 그러면 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬워서 필요한 시점에 데이터 구조를 변경하기도 쉬워지기 때문이다.
- 컬렉션 Getter를 제공하되 내부 컬렉션의 복제본을 반환하는 방법이 있다.
- 컬렉션에 대해서는 어느 정도 강박증을 갖고 불필요한 복제본을 만드는 편이, 예상치 못한 수정이 촉발한 오류를 디버깅하는 것보다 낫다.
- 컬렉션 관리를 책임지는 클래스라면 항상 복제본을 제공해야 한다. 그리고 나는 컬렉션을 변경할 가능성이 있는 작업을 할 때도 습관적으로 복제본을 만든다.

### 7.3 기본형을 객체로 바꾸기(Replace Primitive with Object)
- 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의한다.
- 목적은 어디까지나 클래스를 새로운 동작을 담는 장소로 활용하기 위해서다. 새로운 동작이란 새로 구현한 것일 수도, 다른 곳에서 옮겨온 것일 수도 있다.

### 7.4 임시 변수를 질의함수로 바꾸기(Replace Temp with Query)
- 임시 변수를 사용하면 값을 계산하는 코드가 반복되는 걸 줄이고 (변수 이름을 통해) 값의 의미를 설명할 수도 있어서 유용하다. 그런데 한 걸음 더 나아가 아예 함수로 만들어 사용하는 편이 나을 때가 많다.
- 긴 함수를 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면 일이 수월해진다.
- 변수 대신 함수로 만들어두면 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어든다.
- 가장 단순한 예로, 변수에 값을 한 번 대입한 뒤 더 복잡한 코드 덩어리에서 여러 차례 다시 대입하는 경우는 모두 질의 함수로 추출해야 한다.

### 7.5 클래스 추출하기(Extract Class)
- 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다.
- 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다.
- 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다.
- 저수준 메서드, 즉 다른 메서드를 호출하기보다 호출을 당하는 일이 많은 메서드부터 옮긴다.

### 7.6 클래스 인라인하기(Inline Class)
- 더 이상 제 역할을 못 해서 그대로 두면 안 되는 클래스는 인라인한다.
- 두 클래스의 기능을 지금과 다르게 배분하고 싶을 떄도 클래스를 인라인한다.

### 7.7 위임 숨기기(Hide Delegate)
- 캡슐화는 모듈들이 시스템의 다른 부분에 알아야 할 내용을 줄여준다. 캡슐화가 잘 되어 있다면 무언가를 변경해야 할 때 함께 고려해야 할 모듈 수가 적어져서 코드를 변경하기가 훨씬 쉬워진다.
- 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다.
- 클라이언트는 부서 클래스의 작동 방식, 다시 말해 부서 클래스가 관리자 정보를 제공한다는 사실을 알아야 한다. 이러한 의존성을 줄이려면 클라이언트가 부서 클래스를 볼 수 없게 숨기고, 대신 사람 클래스에 간단한 위임 메서드를 만들면 된다.

### 7.8 중개자 제거하기(Remove Middle Man)
- 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야 하는데, 이렇게 기능을 추가하다 보면 단순히 전달만 하는 위임 메서드들이 점점 성가셔진다.
- 그러면 서버 클래스는 그저 중개자(middle man) 역할로 전락하여, 차라리 클라이언트가 위임 객체를 직접 호출하는게 나을 수 있다.
- 위임 숨기기나 중개자 제거하기를 적당히 섞어도 된다.

### 7.9 알고리즘 교체하기(Substitute Algorithm)
- 더 간명한 방법을 찾아내면 복잡한 기존 코드를 간명한 방식으로 고친다.
- 반드시 메서드를 가능한 한 잘게 나눴는지 확인해야 한다.

---

# 8. 기능 이동

### 8.1 함수 옮기기(Move Function)
- 좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘 되어 있느냐를 뜻하는 모듈성(modularity)이다. 모듈성이란 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력이다.
- 모듈성을 높이려면 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 한다.
- 대상 함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 또 무엇이 있는지, 대상 함수가 사용하는 데이터는 무엇인지를 살펴봐야 한다.
- 중첩 함수를 사용하다 보면 숨겨진 데이터까지 상호 의존하기가 아주 쉬우니 중첩 함수는 되도록 만들지 말자.

### 8.2 필드 옮기기(Move Field)
- 경험과 도메인 주도 설계 같은 기술이 데이터 구조 잡기에 좋다.
- 프로젝트를 진행할수록 우리는 문제 도메인과 데이터 구조에 대해 더 많은 것을 배우게 된다.
- 현재 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다.
- 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해야만 한다면 필드의 위치가 잘못되었다는 신호다.
- 클래스의 데이터들은 접근자 메서드들 뒤에 감춰져(캡슐화되어) 있으므로 클래스에 곁들여진 함수(메서드)들은 데이터를 이리저리 옮기는 작업을 쉽게 해준다.

### 8.3 문장을 함수로 옮기기(Move Statements into Function)
- 특정 함수를 호출하는 코드가 나올 때마다 그 앞이나 뒤에서 똑같은 코드가 추가로 실행되는 모습을 보면, 나는 그 반복되는 부분을 피호출 함수로 합치는 방법을 궁리한다.
- 문장들을 함수로 옮기려면 그 문장들이 피호출 함수의 일부라는 확신이 있어야 한다.
- 타겟 함수를 호출하는 곳이 한 곳뿐이면, 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다.
- 호출자가 둘 이상이면 호출자 중 하나에서 \'타겟 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께\' 다른 함수로 추출한다.

### 8.4 문장을 호출한 곳으로 옮기기(Move Statements into Callers)
- 여러 곳에서 사용하던 기능이 일부 호출자에게는 다르게 동작하도록 바뀌어야 한다면 이런 일이 벌어진다.
- 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야 한다.

### 8.5 인라인 코드를 함수 호출로 바꾸기(Replace Inline Code with Function Call)
- 함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때문에 함수를 활용하면 코드를 이해하기 쉬워진다.
- 함수는 중복을 없애는 데도 효과적이다.
- 이미 존재하는 함수와 똑같은 일을 하는 인라인 코드를 발견하면 보통은 해당 코드를 함수 호출로 대체하길 원할 것이다.
- 예외가 있다면 기존 함수의 코드를 수정하더라도 인라인 코드의 동작은 바뀌지 않아야 할 때 뿐이다.

### 8.6 문장 슬라이드하기(Slide Statements)
- 하나의 데이터 구조를 이용하는 문장들은 (다른 데이터를 이용하는 코드 사이에 흩어져 있기보다는) 한데 모여 있어야 좋다.
- 모든 변수 선언을 함수 첫머리에 모아두는 것보다, 변수를 처음 사용할 때 선언하는 스타일을 선호한다.
- 요소를 선언하는 곳과 사용하는 곳을 가까이 두기를 좋아해서 선언 코드를 슬라이드하여 처음 사용하는 곳까지 끌어내리는 일을 자주 한다.
- 부수효과(side effect)가 있는 코드를 슬라이드하거나 부수효과가 있는 코드를 건너뛰어야 한다면 훨씬 신중해야 한다.
- 상태 갱신에 특히나 신경 써야 하기 때문에 상태를 갱신하는 코드 자체를 최대한 제거하는 게 좋다.
- 슬라이드 후 테스트가 실패했을 때 가장 좋은 대처는 더 작게 슬라이드해보는 것이다.
- 조건문 밖으로 슬라이드할 때는 중복 로직이 제거될 것이고, 조건문 안으로 슬라이드할 때는 반대로 중복 로직이 추가될 것이다.
- **항상 단계를 잘게 나눠 리팩터링한다.**

### 8.7 반복문 쪼개기(Split Loop)
- 반복문 쪼개기는 서로 다른 일들이 한 함수에서 이뤄지고 있다는 신호일 수 있다.
- 리팩터링과 최적화를 구분하자.
- 긴 리스트를 반복하더라도 병목으로 이어지는 경우는 매우 드물다. 오히려 반복문 쪼개기가 다른 더 강력한 최적화를 적용할 수 있는 길을 열어주기도 한다.

### 8.8 반복문을 파이프라인으로 바꾸기(Replace Loop with Pipeline)
- 컬렉션 파이프라인을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다.

### 8.9 죽은 코드 제거하기(Remove Dead Code)
- 코드가 더 이상 사용되지 않게 됐다면 지워야 한다.

---

# 9. 데이터 조직화

### 9.1 변수 쪼개기(Split Variable)
- 변수에는 값을 단 한 번만 대입해야 한다. 대입이 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다.
- 역할이 둘 이상인 변수가 있다면 쪼개야 한다.

### 9.2 필드 이름 바꾸기(Rename Field)
- 모든 변경을 한 번에 수행하는 대신 작은 단계들로 나눠 독립적으로 수행할 수 있게 된다.
- **리팩터링 도중 테스트에 실패한다면 더 작은 단계로 나눠 진행해야 한다는 신호임을 잊지 말자.**

### 9.3 파생 변수를 질의 함수로 바꾸기(Replace Derived Variable with Query)
- 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.
- 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거한다.

### 9.4 참조를 값으로 바꾸기(Change Reference to Value)
- 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.
- 불변 데이터 값은 프로그램 외부로 건네줘도 나중에 그 값이 나 몰래 바뀌어서 내부에 영향을 줄까 염려하지 않아도 된다.
- 특정 객체를 여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 한다.

### 9.5 값을 참조로 바꾸기(Change Value to Reference)
- 복사본이 많이 생겨서 가끔은 메모리가 부족할 수도 있지만, 다른 성능 이슈와 마찬가지로 아주 드문 일이다.
- 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 데이터 일관성이 깨져버린다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는게 좋다.
- 같은 엔티티를 표현하는 객체가 여러 개 만들어지면 혼란이 생긴다.
- 항상 물리적으로 똑같은 고객 객체를 사용하고 싶다면 먼저 이 유일한 객체를 저장해둘 곳이 있어야 한다. 나는 저장소 객체(repository object)를 사용하는 편이다.

### 9.6 매직 리터럴 바꾸기(Replace Magic Literal)
- 코드를 읽는 사람이 이 값의 의미를 모른다면 숫자 자체로는 의미를 명확히 알려주지 못하므로 매직 리터럴이라 할 수 있다.

---

### Reference
- [리팩터링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기](http://www.yes24.com/Product/Goods/89649360)
- [refactoring.com](https://refactoring.com)
