---
layout: entry
title: 클린 아키텍처(Clean Architecture) 2
author: 김성중
author-email: ajax0615@gmail.com
description: 클린 아키텍처(Clean Architecture)를 읽고 정리한 글 입니다.
keywords: 클린 아키텍처, Clean Architecture
publish: true
---

![Clean Architecture](/images/2019/10/26/clean_architecture.JPG "Clean Architecture"){: .center-image }

# 15장. 아키텍처란?
아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다. 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

### 개발
시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 만들어야만 한다. 일례로 팀이 개발자 다섯명으로 구성될 정도로 작다면, 잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여 모노리틱 *monolithic* 시스템을 개발할 수 있다. 다른 한편으로 일곱 명씩 구성된 총 다섯 팀이 시스템 개발을 한다면 이 시스템의 아키텍처는 다섯 개의 컴포넌트(각 팀마다 하나씩) 발전될 가능성이 높다.

### 배포
소프트웨어 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.

### 운영
시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 *first-class* 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다. 이를 통해 시스템을 이해하기 쉬워지며, 따라서 갭라과 유지보수에 큰 도움이 된다.

### 유지보수
유지보수는 모든 측면에서 봤을때 비용이 가장 많이 든다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리한다. 이를 통해 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장애가 발생할 위험을 크게 줄일 수 있다.

### 선택사항 열어 두기
소프트웨어를 부드럽게 유지하는 방법은 **중요치 않은 세부사항** 을 가능한 많이, 그리고 가능한 한 오랫동안 열어두는 것이다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다. 이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.

- 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
- 개발 초기에는 웹 서버를 선택할 필요가 없다.
- 개발 초기에는 REST를 적용할 필요가 없다.
- 개발 초기에는 의존성 주입 *dependency injection* 프레임워크를 적용할 필요가 없다.

 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다. 이를 통해 다양한 실험을 시도해볼 수 있는 선택지도 열어 둘 수 있다.

---

# 16장. 독립성

### 유스케이스
좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

### 운영
시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다. 시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다.

### 개발
각 팀이 독립적으로 행동하기 편한 아키텍처를 만들려면 잘 격리되어 독립적으로 개발 가능항 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

### 배포
좋은 아키텍처는 즉각적인 배포 *immediate deployment* 가 가능해야 한다. 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.

### 선택사항 열어두기
좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

### 계층 결합 분리
아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지는 못한다. 따라서 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.

업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거, 혹은 더 범용적일 수도 있다. 예를 들어 입력 필드 유효성 검사는 애플리케이션 자체와 밀접하게 관련된 업무 규칙이다. 반대로 계좌의 이자 계산이나 재고품 집계는 업무 도메인에 더 밀접하게 연관된 업무 규칙이다. 이들 서로 다른 두 유형의 규칙은 각자 다른 속도로, 그리고 다른 이유로 변경될 것이다. 따라서 이들 규칙은 서로 분리하고, 독립적으로 변경할 수 있도록 만들어야만 한다.

### 유스케이스 결합 분리
시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.

### 결합 분리 모드
유스케이스와 계층 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체 *hot-swap* 할 수 있다. 새로운 유스케이스를 추가하는 일은 시스템의 나버지는 그대로 둔 채 새로운 jar 파일이나 서비스 몇 개를 추가하는 정도로 단순한 일이 된다.

### 중복
예를 들어 두 유스케이스의 화면 구조가 매우 비슷하다고 가정해보자. 이는 우발적 중복일 가능성이 높다. 시간이 지나면서 두 화면은 서로 다른 방향으로 분기하며, 결국에는 매우 다른 모습을 가질 가능성이 높다. 이러한 이유로, 해당 코드를 통합하지 않도록 유의해야 한다.

### 결합 분리 모드(다시)
계층과 유스케이스의 결합을 분리하는 방법은 다양하다.

- **Source level**: 소스 코드 모듈 사이의 의존성을 제어할 수 있다. 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다.
- **Deployment level**: jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 이를 통해 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다.
- **Service level**: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. 이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다(예, 서비스 또는 마이크로서비스).

컴포넌트가 서비스화될 가능성이 있다면 나는 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈추는 방식을 선호한다.

좋은 아키텍처는 시스템이 모노로틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.

---

# 17장. 경계: 선 긋기
프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정 등을 포함한 유스케이스와 관련이 없는 시스템의 업무 요구사항을 너무 일찍 결정하면 **결합** *coupling* 을 만든다. 그리고 이는 인적 자원의 효율을 떨어뜨리는 요인이 된다.

### 어떻게 선을 그을까? 그리고 언제 그을까?
관련이 있는 것과 없는 것 사이에 선을 긋는다. GUI는 업무 규칙과는 관련이 없기 때문에, 이 둘 사이는 반드시 선이 있어야 한다.

업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다. 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부다. 이러한 함수 집합을 통해서 우리는 데이터베이스를 인터페이스 뒤로 숨길 수 있다.

![인터페이스 뒤로 숨은 데이터베이스](/images/2019/11/05/17_1.png "인터페이스 뒤로 숨은 데이터베이스"){: .center-image }

경계선은 상속 관계를 횡단하면서 DatabaseInterface 바로 아래에 그어진다(그림 17.2).

![경계선](/images/2019/11/05/17_2.png "경계선"){: .center-image }

DatabaseAccess에서 출발하는 두 화살표는 모두 바깥쪽으로 향한다. DatabaseAccess가 존재한다는 사실을 알고 있는 클래스는 없다는 뜻이다.

![업무 규칙과 데이터베이스 컴포넌트](/images/2019/11/05/17_3.png "업무 규칙과 데이터베이스 컴포넌트"){: .center-image }

Database 컴포넌트는 BusinessRule 컴포넌트에 대해 알고 있다. BusinessRule는 Database에 관해 알지 못한다. 두 컴포넌트 사이에 이러한 경계선을 그리고 화살표의 방향이 BusinessRule를 향하도록 만들었으므로, BusinessRule에서는 어떤 종류의 데이터베이스도 사용할 수 있음을 알 수 있다. Database 컴포넌트는 다양한 구현체로 교체될 수 있으며, BusinessRule는 조금도 개의치 않는다.

### 입력과 출력은?
예를 들어, 비디오 게임에서 화면, 마우스, 버튼, 음향은 인터페이스다. 이러한 인터페이스 뒤에는 인터페이스를 조작하는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다. 그리고 모델은 인터페이스를 전혀 필요로 하지 않는다. 인터페이스는 모델에게 있어 중요하지 않다. 중요한 것은 업무 규칙이다.

따라서 이번에도 GUI와 BusinessRule 컴포넌트가 경계선에 의해 분할된다(그림17.4). 관련성이 낮은 컴포넌트가 관련성이 높은 컴포넌트에 의존한다.

![GUI와 BusinessRule 컴포넌트 사이의 경계](/images/2019/11/05/17_4.png "GUI와 BusinessRule 컴포넌트 사이의 경계"){: .center-image }

GUI는 다른 종류의 인터페이스로 얼마든지 교체할 수 있으며 BusinessRule는 전혀 개의치 않는다는 사실을 알 수 있다.

### 플러그인 아키텍처
소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기다. 선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 분리되어 있고, 또한 독립적이다(그림 17.5)

![업무 규칙에 플러그인 형태로 연결하기](/images/2019/11/05/17_5.png "업무 규칙에 플러그인 형태로 연결하기"){: .center-image }

### 플러그인에 대한 논의
예를 들어 누군가가 웹 페이지의 포맷을 변경하거나 데이터베이스 스키마를 변경하더라도 업무 규칙은 깨지지 않기를 바란다. 마찬가지로 시스템에서 한 부분이 변경되더라도 관련 없는 나머지 부분이 망가지길 원치 않는다.

시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다. GUI가 업무 규칙에 플러그인 형태로 연결되면 GUI에서 발생한 변경은 절대로 업무 규칙에 영향을 미칠 수 없다.

GUI는 업무 규칙과는 다른 시점에 다른 속도로 변경되므로, 둘 사이에는 반드시 경계가 필요하다. 업무 규칙은 의존성 주입 프레임워크와는 다른 시점에 그리고 다른 이유로 변경되므로, 둘 사이에도 반드시 경계가 필요하다.

---

# 18장. 경계 해부학

### 경계 횡단하기
런타임에 경계를 횡단한다. 함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다. 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

### 두려운 단일체
가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다. 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.

고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다. 이렇게 하면 런타임 의존성은 컴파일타임 의존성과는 반대가 된다. 그림18.2에서 주목할 점은 경계를 횡단할 때 의존성은 모두 오른쪽에서 왼쪽으로, 즉 **고수준 컴포넌트를 향한다** 는 점이다. 또한 데이터 구조의 정의가 호출하는 쪽에 위치한다는 점도 주목하자.

![제어흐름과는 반대로 경계를 횡단한다.](/images/2019/11/05/18_2.png "제어흐름과는 반대로 경계를 횡단한다."){: .center-image }

정적 링크된 모노리티 구조의 실행 파일이라도 이처럼 규칙적인 방식으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는 작업에 큰 도움이 된다.

### 배포형 컴포넌트
.NET DLL, 자바 jar 파일, 루비 젬 Gem, 유닉스 공유 라이브러리 등의 동적 링크 라이브러리들은 아키텍처의 경계가 물리적으로 드러난다. 컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있다. 배포 과정에서만 차이가 날 뿐, 단일체와 동일하다.

### 스레드
스레드는 아키텍처 경계도 아니며 배포 단위도 아니다. 스레드는 실행 계획과 순서를 체계화하는 방법에 가깝다.

### 로컬 프로세스
로컬 프로세스 간 분리 전략은 단일체나 바이너리 컴포넌트의 경우와 동일하다. 소스 코드 의존성의 화살표는 단일체나 바이너리 컴포넌트와 동일한 방향으로 경계를 횡단한다. 즉, 항상 고수준 컴포넌트를 향한다.

### 서비스
물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다. 서비스는 자신의 물리적 위치에 구애 받지 않고, 모든 통신이 네트워크를 통해 이뤄진다고 가정한다.

저수준 서비스는 반드시 고수준 서비스에 \'플러그인\' 되어야 한다. 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예를 들면, URI)도 절대 포함해서는 안 된다.

---

# Reference
- [클린 아키텍처: 소프트웨어 구조와 설계의 원칙](http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788966262472)
- [Clean Architecture](http://putregai.com/sbooks/clean_arch.pdf)
